import json
import sys
import time
from typing import List, Dict, Any, Optional, Protocol
from abc import ABC, abstractmethod


class TestCaseResult:
    """Represents the result of a single test case."""
    
    def __init__(self, test_case_index: int, pass_: bool, error_message: Optional[str], 
                 execution_time_in_ms: int, input_: Any, expected_output: Any, 
                 actual_output: Any, is_hidden: bool = False):
        self.test_case_index = test_case_index
        self.pass_ = pass_
        self.error_message = error_message
        self.execution_time_in_ms = execution_time_in_ms
        self.input_ = input_
        self.expected_output = expected_output
        self.actual_output = actual_output
        self.is_hidden = is_hidden

    def to_dict(self) -> Dict[str, Any]:
        return {
            "testCaseIndex": self.test_case_index,
            "pass": self.pass_,
            "errorMessage": self.error_message,
            "executionTimeInMs": self.execution_time_in_ms,
            "input": self.input_,
            "expectedOutput": self.expected_output,
            "actualOutput": self.actual_output,
            "isHidden": self.is_hidden
        }


class SubmissionResult:
    """Represents the overall submission result."""
    
    def __init__(self):
        self.pass_: bool = False
        self.test_case_count: int = 0
        self.passed_test_cases: int = 0
        self.failed_test_cases: int = 0
        self.error_message: str = ""
        self.execution_time_in_ms: int = 0
        self.test_case_results: List[Dict[str, Any]] = []

    def to_dict(self) -> Dict[str, Any]:
        return {
            "pass": self.pass_,
            "testCaseCount": self.test_case_count,
            "passedTestCases": self.passed_test_cases,
            "failedTestCases": self.failed_test_cases,
            "errorMessage": self.error_message,
            "executionTimeInMs": self.execution_time_in_ms,
            "testCaseResults": self.test_case_results
        }


class IProblemDriver(Protocol):
    """Interface that problem-specific drivers should implement."""
    
    def parse_test_cases(self, input_data: Any, expected_output: Any) -> List[Dict[str, Any]]:
        """Parse input and expected output into structured test cases."""
        ...
    
    def execute_test_case(self, test_case: Dict[str, Any], index: int) -> Any:
        """Execute a single test case."""
        ...
    
    def compare_results(self, actual: Any, expected: Any) -> bool:
        """Compare actual and expected results."""
        ...
    
    def format_error_message(self, actual: Any, expected: Any) -> str:
        """Format error message when test fails."""
        ...


class BaseDriver:
    """Base driver class that handles common test execution logic."""
    
    def __init__(self, problem_driver: IProblemDriver):
        self.problem_driver = problem_driver

    def run(self):
        """Main entry point for the driver."""
        if len(sys.argv) < 4:
            print("Usage: python driver.py <inputFilePath> <expectedOutputFilePath> <resultFilePath>", file=sys.stderr)
            sys.exit(1)

        input_path = sys.argv[1]
        expected_path = sys.argv[2]
        result_path = sys.argv[3]

        try:
            with open(input_path, 'r') as f:
                input_content = f.read()
            with open(expected_path, 'r') as f:
                expected_output = f.read()
            
            start_time = time.time()
            results = self.run_tests(input_content, expected_output)
            end_time = time.time()
            results.execution_time_in_ms = int((end_time - start_time) * 1000)

            with open(result_path, 'w') as f:
                json.dump(results.to_dict(), f, indent=2)

        except Exception as ex:
            results = SubmissionResult()
            results.error_message = str(ex)
            
            with open(result_path, 'w') as f:
                json.dump(results.to_dict(), f, indent=2)
            sys.exit(1)

    def run_tests(self, input_json_str: str, expected_output_json_str: str) -> SubmissionResult:
        """Orchestrates the test execution process."""
        input_data = json.loads(input_json_str)
        expected_output = json.loads(expected_output_json_str)
        
        test_cases = self.problem_driver.parse_test_cases(input_data, expected_output)
        test_results = self.execute_test_cases(test_cases)
        
        return self.aggregate_results(test_results)

    def execute_test_cases(self, test_cases: List[Dict[str, Any]]) -> List[TestCaseResult]:
        """Executes all test cases and collects results."""
        results = []
        
        for index, test_case in enumerate(test_cases):
            print(f"|derpcode-start-test-{index}|")
            test_case_start = time.time()
            
            try:
                actual_output = self.problem_driver.execute_test_case(test_case, index)
                passed = self.problem_driver.compare_results(actual_output, test_case['expectedOutput'])
                
                print(f"|derpcode-end-test-{index}|")
                
                test_case_result = TestCaseResult(
                    test_case_index=index,
                    pass_=passed,
                    error_message=None if passed else self.problem_driver.format_error_message(actual_output, test_case['expectedOutput']),
                    execution_time_in_ms=int((time.time() - test_case_start) * 1000),
                    input_=test_case['input'],
                    expected_output=test_case['expectedOutput'],
                    actual_output=actual_output,
                    is_hidden=False
                )
                
                results.append(test_case_result)
                
            except Exception as err:
                print(f"|derpcode-end-test-{index}|")
                
                test_case_result = TestCaseResult(
                    test_case_index=index,
                    pass_=False,
                    error_message=str(err),
                    execution_time_in_ms=int((time.time() - test_case_start) * 1000),
                    input_=test_case['input'],
                    expected_output=test_case['expectedOutput'],
                    actual_output=None,
                    is_hidden=False
                )
                
                results.append(test_case_result)
        
        return results

    def aggregate_results(self, test_results: List[TestCaseResult]) -> SubmissionResult:
        """Aggregates individual test results into final result."""
        passed_test_cases = sum(1 for result in test_results if result.pass_)
        
        submission_result = SubmissionResult()
        submission_result.test_case_count = len(test_results)
        submission_result.passed_test_cases = passed_test_cases
        submission_result.failed_test_cases = len(test_results) - passed_test_cases
        submission_result.pass_ = passed_test_cases == len(test_results)
        submission_result.test_case_results = [result.to_dict() for result in test_results]
        
        return submission_result


class BaseProblemDriver:
    """Base implementation of IProblemDriver with common functionality."""
    
    def compare_results(self, actual: Any, expected: Any) -> bool:
        """Default comparison using equality."""
        return actual == expected
    
    def format_error_message(self, actual: Any, expected: Any) -> str:
        """Default error message format."""
        return f"Expected {expected} but got {actual}"
