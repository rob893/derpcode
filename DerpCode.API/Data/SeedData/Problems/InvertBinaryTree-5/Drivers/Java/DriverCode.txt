import java.util.*;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;

/**
 * Problem-specific driver for InvertBinaryTree problem.
 */
class InvertBinaryTreeDriver extends ProblemDriverBase {
    @Override
    public List<TestCase> parseTestCases(JsonArray input, JsonArray expectedOutput) {
        List<TestCase> testCases = new ArrayList<>();
        
        for (int i = 0; i < input.size(); i++) {
            JsonArray inputArray = input.get(i).getAsJsonArray();
            JsonArray expectedArray = expectedOutput.get(i).getAsJsonArray();
            
            TreeNode inputTree = parseTree(inputArray);
            TreeNode expectedTree = parseTree(expectedArray);
            
            testCases.add(new TestCase(inputTree, expectedTree));
        }
        
        return testCases;
    }

    @Override
    public Object executeTestCase(TestCase testCase, int index) throws Exception {
        TreeNode input = (TreeNode) testCase.getInput();
        Solution solution = new Solution();
        return solution.invertTree(input);
    }

    @Override
    public boolean compareResults(Object actual, Object expected) {
        return compareTrees((TreeNode) actual, (TreeNode) expected);
    }
    
    private TreeNode parseTree(JsonArray node) {
        if (node == null || node.size() == 0) {
            return null;
        }
        
        Queue<TreeNode> queue = new LinkedList<>();
        TreeNode root = new TreeNode(node.get(0).getAsInt());
        queue.offer(root);
        
        int index = 1;
        while (!queue.isEmpty() && index < node.size()) {
            TreeNode current = queue.poll();
            
            if (index < node.size() && !node.get(index).isJsonNull()) {
                current.left = new TreeNode(node.get(index).getAsInt());
                queue.offer(current.left);
            }
            index++;
            
            if (index < node.size() && !node.get(index).isJsonNull()) {
                current.right = new TreeNode(node.get(index).getAsInt());
                queue.offer(current.right);
            }
            index++;
        }
        
        return root;
    }
    
    private boolean compareTrees(TreeNode tree1, TreeNode tree2) {
        if (tree1 == null && tree2 == null) return true;
        if (tree1 == null || tree2 == null) return false;
        
        return tree1.val == tree2.val && 
               compareTrees(tree1.left, tree2.left) && 
               compareTrees(tree1.right, tree2.right);
    }
}

class Program {
    public static void main(String[] args) {
        // Create and run the driver
        BaseDriver driver = new BaseDriver(new InvertBinaryTreeDriver());
        driver.run(args);
    }
}
