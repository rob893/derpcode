use serde_json::Value;
use std::rc::Rc;
use std::cell::RefCell;
use std::collections::VecDeque;

mod base_driver;
use base_driver::{BaseDriver, ProblemDriver, TestCase};

mod solution;
use solution::{invert_tree, TreeNode};

/// Problem-specific driver for InvertBinaryTree problem.
pub struct InvertBinaryTreeDriver;

impl ProblemDriver for InvertBinaryTreeDriver {
    /// Parse input as tree arrays and expected output as tree arrays.
    fn parse_test_cases(&self, input: &Value, expected_output: &Value) -> Vec<TestCase> {
        let input_array = input.as_array().expect("Input should be an array");
        let expected_array = expected_output.as_array().expect("Expected output should be an array");
        
        let mut test_cases = Vec::new();
        
        for i in 0..input_array.len() {
            test_cases.push(TestCase {
                input: input_array[i].clone(),
                expected_output: expected_array[i].clone(),
            });
        }
        
        test_cases
    }

    /// Execute the invert_tree function with the test case input.
    fn execute_test_case(&self, test_case: &TestCase, _index: usize) -> Result<Value, Box<dyn std::error::Error>> {
        // Build tree from array
        let input_tree = self.build_tree_from_array(&test_case.input)?;
        
        // Run the solution
        let result = invert_tree(input_tree);
        
        // Convert result back to array for comparison
        let result_array = self.tree_to_array(result);
        Ok(serde_json::json!(result_array))
    }

    /// Compare tree arrays.
    fn compare_results(&self, actual: &Value, expected: &Value) -> bool {
        let actual_array = self.value_to_int_array(actual).unwrap_or_default();
        let expected_array = self.value_to_int_array(expected).unwrap_or_default();
        
        self.arrays_equal(&actual_array, &expected_array)
    }
}

impl InvertBinaryTreeDriver {
    fn build_tree_from_array(&self, arr: &Value) -> Result<Option<Rc<RefCell<TreeNode>>>, Box<dyn std::error::Error>> {
        // Handle single integer input (single node tree)
        if let Some(val) = arr.as_i64() {
            return Ok(Some(Rc::new(RefCell::new(TreeNode::new(val as i32)))));
        }
        
        // Handle array input
        if let Some(array) = arr.as_array() {
            if array.is_empty() || array[0].is_null() {
                return Ok(None);
            }
            
            fn build_tree(values: &[Value], index: usize) -> Option<Rc<RefCell<TreeNode>>> {
                if index >= values.len() || values[index].is_null() {
                    return None;
                }
                
                let val = values[index].as_i64().unwrap() as i32;
                let node = Rc::new(RefCell::new(TreeNode::new(val)));
                
                node.borrow_mut().left = build_tree(values, 2 * index + 1);
                node.borrow_mut().right = build_tree(values, 2 * index + 2);
                
                Some(node)
            }
            
            return Ok(build_tree(array, 0));
        }
        
        // Handle null input
        if arr.is_null() {
            return Ok(None);
        }
        
        Err("Input must be an array, integer, or null".into())
    }

    fn tree_to_array(&self, root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Option<i32>> {
        if root.is_none() {
            return vec![];
        }
        
        let mut result = Vec::new();
        let mut queue = VecDeque::new();
        queue.push_back(root);
        
        while let Some(node_opt) = queue.pop_front() {
            if let Some(node) = node_opt {
                result.push(Some(node.borrow().val));
                queue.push_back(node.borrow().left.clone());
                queue.push_back(node.borrow().right.clone());
            } else {
                result.push(None);
            }
        }
        
        // Remove trailing nulls
        while let Some(&None) = result.last() {
            result.pop();
        }
        
        result
    }

    fn value_to_int_array(&self, value: &Value) -> Result<Vec<Option<i32>>, Box<dyn std::error::Error>> {
        // Handle single integer (single node tree)
        if let Some(val) = value.as_i64() {
            return Ok(vec![Some(val as i32)]);
        }
        
        // Handle array
        if let Some(array) = value.as_array() {
            let mut result = Vec::new();
            
            for item in array {
                if item.is_null() {
                    result.push(None);
                } else {
                    result.push(Some(item.as_i64().ok_or("Item is not a number")? as i32));
                }
            }
            
            return Ok(result);
        }
        
        // Handle null
        if value.is_null() {
            return Ok(vec![]);
        }
        
        Err("Value must be an array, integer, or null".into())
    }

    fn arrays_equal(&self, arr1: &[Option<i32>], arr2: &[Option<i32>]) -> bool {
        if arr1.len() != arr2.len() {
            return false;
        }
        
        for i in 0..arr1.len() {
            if arr1[i] != arr2[i] {
                return false;
            }
        }
        
        true
    }
}

fn main() {
    // Create and run the driver
    let driver = BaseDriver::new(InvertBinaryTreeDriver);
    driver.run();
}
