import json
import sys
from typing import List, Dict, Any, Optional
from base_driver import BaseDriver, BaseProblemDriver
from solution import Solution, TreeNode


class InvertBinaryTreeDriver(BaseProblemDriver):
    """Problem-specific driver for InvertBinaryTree problem."""

    def parse_test_cases(self, input_data: Any, expected_output: Any) -> List[Dict[str, Any]]:
        """Parse input as array of tree arrays and expected output as array of tree arrays."""
        input_array = json.loads(input_data) if isinstance(input_data, str) else input_data
        expected_array = json.loads(expected_output) if isinstance(expected_output, str) else expected_output
        
        test_cases = []
        
        for i in range(len(input_array)):
            test_cases.append({
                'input': input_array[i],
                'expectedOutput': expected_array[i] if i < len(expected_array) else []
            })
        
        return test_cases

    def execute_test_case(self, test_case: Dict[str, Any], index: int) -> Any:
        """Execute the invertTree method with the test case input."""
        input_tree_array = test_case['input']
        
        # Build input tree from array
        input_tree = self.build_tree_from_array(input_tree_array)
        
        # Run the solution
        solution = Solution()
        result = solution.invertTree(input_tree)
        
        # Convert result back to array for comparison
        return self.tree_to_array(result)

    def compare_results(self, actual: Any, expected: Any) -> bool:
        """Compare tree arrays."""
        return self.arrays_equal(actual, expected)

    def format_error_message(self, actual: Any, expected: Any) -> str:
        """Format error message for failed tests."""
        return f"Expected {expected} but got {actual}"

    def build_tree_from_array(self, arr):
        """Build a binary tree from array representation."""
        if not arr or arr[0] is None:
            return None
        
        def build_tree(values, index):
            if index >= len(values) or values[index] is None:
                return None
            
            node = TreeNode(values[index])
            node.left = build_tree(values, 2 * index + 1)
            node.right = build_tree(values, 2 * index + 2)
            return node
        
        return build_tree(arr, 0)

    def tree_to_array(self, root):
        """Convert binary tree to array representation."""
        if not root:
            return []
        
        result = []
        queue = [root]
        
        while queue:
            node = queue.pop(0)
            if node is None:
                result.append(None)
            else:
                result.append(node.val)
                queue.append(node.left)
                queue.append(node.right)
        
        # Remove trailing nulls
        while result and result[-1] is None:
            result.pop()
        
        return result

    def arrays_equal(self, arr1, arr2):
        """Compare two arrays for equality."""
        if len(arr1) != len(arr2):
            return False
        
        for i in range(len(arr1)):
            if arr1[i] != arr2[i]:
                return False
        
        return True


def main():
    """Main entry point for the driver."""
    # Create and run the driver
    driver = BaseDriver(InvertBinaryTreeDriver())
    driver.run()


if __name__ == "__main__":
    main()
