import { ProblemDriverBase, BaseDriver, TestCase } from './base-driver';
import { invertTree, TreeNode } from './solution';

/**
 * Problem-specific driver for InvertBinaryTree problem.
 */
class InvertBinaryTreeDriver extends ProblemDriverBase {
    /**
     * Parse input as array representations of binary trees.
     */
    parseTestCases(input: any, expectedOutput: any): TestCase[] {
        const testCases: TestCase[] = [];
        
        for (let i = 0; i < input.length; i++) {
            testCases.push({
                input: input[i],
                expectedOutput: expectedOutput[i]
            });
        }
        
        return testCases;
    }

    /**
     * Execute the invertTree function with the test case input.
     */
    executeTestCase(testCase: TestCase, index: number): any {
        // Build input tree from array
        const inputTree = this.buildTreeFromArray(testCase.input);
        
        // Run the solution
        const result = invertTree(inputTree);
        
        // Convert result back to array for comparison
        return this.treeToArray(result);
    }

    /**
     * Compare result arrays.
     */
    compareResults(actual: any, expected: any): boolean {
        return this.arraysEqual(actual, expected);
    }

    private buildTreeFromArray(arr: (number | null)[]): TreeNode | null {
        if (!arr || arr.length === 0 || arr[0] === null) {
            return null;
        }
        
        function buildTree(values: (number | null)[], index: number): TreeNode | null {
            if (index >= values.length || values[index] === null) {
                return null;
            }
            
            const node = new TreeNode(values[index]!);
            node.left = buildTree(values, 2 * index + 1);
            node.right = buildTree(values, 2 * index + 2);
            return node;
        }
        
        return buildTree(arr, 0);
    }

    private treeToArray(root: TreeNode | null): (number | null)[] {
        if (!root) {
            return [];
        }
        
        const result: (number | null)[] = [];
        const queue: (TreeNode | null)[] = [root];
        
        while (queue.length > 0) {
            const node = queue.shift();
            if (node === null || node === undefined) {
                result.push(null);
            } else {
                result.push(node.val);
                queue.push(node.left);
                queue.push(node.right);
            }
        }
        
        // Remove trailing nulls
        while (result.length > 0 && result[result.length - 1] === null) {
            result.pop();
        }
        
        return result;
    }

    private arraysEqual(arr1: (number | null)[], arr2: (number | null)[]): boolean {
        if (arr1.length !== arr2.length) {
            return false;
        }
        
        for (let i = 0; i < arr1.length; i++) {
            if (arr1[i] !== arr2[i]) {
                return false;
            }
        }
        
        return true;
    }
}

// Create and run the driver
const driver = new BaseDriver(new InvertBinaryTreeDriver());
driver.run();
