#pragma warning disable CS8602
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text.Json;

public class Program
{
    private class SubmissionResult
    {
        public bool Pass { get; set; }
        public int TestCaseCount { get; set; }
        public int PassedTestCases { get; set; }
        public int FailedTestCases { get; set; }
        public string ErrorMessage { get; set; } = string.Empty;
        public long ExecutionTimeInMs { get; set; }
        public List<TestCaseResult> TestCaseResults { get; set; } = new List<TestCaseResult>();
    }

    private class TestCaseResult
    {
        public int TestCaseIndex { get; set; }
        public bool Pass { get; set; }
        public string? ErrorMessage { get; set; }
        public int ExecutionTimeInMs { get; set; }
        public object? Input { get; set; }
        public object? ExpectedOutput { get; set; }
        public object? ActualOutput { get; set; }
        public bool IsHidden { get; set; }
    }

    public static void Main(string[] args)
    {
        if (args.Length < 3)
        {
            Console.Error.WriteLine("Usage: dotnet run <inputFilePath> <expectedOutputFilePath> <resultFilePath>");
            Environment.Exit(1);
        }

        string inputPath = args[0];
        string expectedPath = args[1];
        string resultPath = args[2];

        try
        {
            string input = File.ReadAllText(inputPath);
            string expectedOutput = File.ReadAllText(expectedPath);
            var sw = Stopwatch.StartNew();
            
            var result = RunTests(input, expectedOutput);
            
            sw.Stop();
            result.ExecutionTimeInMs = sw.ElapsedMilliseconds;

            string json = JsonSerializer.Serialize(result, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            });

            File.WriteAllText(resultPath, json);
        }
        catch (Exception ex)
        {
            var errorResult = new SubmissionResult
            {
                Pass = false,
                TestCaseCount = 0,
                PassedTestCases = 0,
                FailedTestCases = 0,
                ErrorMessage = ex.Message,
                ExecutionTimeInMs = 0,
                TestCaseResults = new List<TestCaseResult>()
            };

            string json = JsonSerializer.Serialize(errorResult, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            });

            File.WriteAllText(args[2], json);
        }
    }

    private static SubmissionResult RunTests(string inputJsonStr, string expectedOutputJsonStr)
    {
        // Parse test cases
        JsonElement inputArray, expectedArray;
        
        using (var inputDoc = JsonDocument.Parse(inputJsonStr))
        using (var expectedDoc = JsonDocument.Parse(expectedOutputJsonStr))
        {
            inputArray = inputDoc.RootElement.Clone();
            expectedArray = expectedDoc.RootElement.Clone();
        }

        int testCaseCount = inputArray.GetArrayLength();
        int passedTestCases = 0;
        int failedTestCases = 0;
        var testCaseResults = new List<TestCaseResult>();

        var solution = new Solution();

        for (int i = 0; i < testCaseCount; i++)
        {
            Console.WriteLine($"|derpcode-start-test-{i}|");
            var testCaseSw = Stopwatch.StartNew();
            
            try
            {
                // Build input tree from array
                var inputTree = BuildTreeFromArray(inputArray[i]);
                
                // Run the solution
                var result = solution.InvertTree(inputTree);
                
                // Convert result back to array for comparison
                var actualOutput = TreeToArray(result);
                
                testCaseSw.Stop();
                Console.WriteLine($"|derpcode-end-test-{i}|");
                
                // Get expected output
                var expectedOutput = JsonElementToIntArray(expectedArray[i]);
                
                // Compare arrays
                bool passed = ArraysEqual(actualOutput, expectedOutput);

                testCaseResults.Add(new TestCaseResult
                {
                    TestCaseIndex = i,
                    Pass = passed,
                    ErrorMessage = passed ? null : $"Expected {string.Join(",", expectedOutput ?? new int?[0])} but got {string.Join(",", actualOutput ?? new int?[0])}",
                    ExecutionTimeInMs = (int)testCaseSw.ElapsedMilliseconds,
                    Input = JsonElementToIntArray(inputArray[i]),
                    ExpectedOutput = expectedOutput,
                    ActualOutput = actualOutput,
                    IsHidden = false
                });

                if (passed)
                {
                    passedTestCases++;
                }
                else
                {
                    failedTestCases++;
                }
            }
            catch (Exception ex)
            {
                testCaseSw.Stop();
                Console.WriteLine($"|derpcode-end-test-{i}|");
                
                testCaseResults.Add(new TestCaseResult
                {
                    TestCaseIndex = i,
                    Pass = false,
                    ErrorMessage = ex.Message,
                    ExecutionTimeInMs = (int)testCaseSw.ElapsedMilliseconds,
                    Input = JsonElementToIntArray(inputArray[i]),
                    ExpectedOutput = JsonElementToIntArray(expectedArray[i]),
                    ActualOutput = null,
                    IsHidden = false
                });
                
                failedTestCases++;
            }
        }

        return new SubmissionResult
        {
            TestCaseCount = testCaseCount,
            PassedTestCases = passedTestCases,
            FailedTestCases = failedTestCases,
            Pass = passedTestCases == testCaseCount,
            TestCaseResults = testCaseResults
        };
    }

    private static TreeNode? BuildTreeFromArray(JsonElement arrayElement)
    {
        if (arrayElement.ValueKind == JsonValueKind.Null || arrayElement.GetArrayLength() == 0)
            return null;

        var values = new int?[arrayElement.GetArrayLength()];
        for (int i = 0; i < arrayElement.GetArrayLength(); i++)
        {
            var element = arrayElement[i];
            values[i] = element.ValueKind == JsonValueKind.Null ? null : element.GetInt32();
        }

        return BuildTree(values, 0);
    }

    private static TreeNode? BuildTree(int?[] values, int index)
    {
        if (index >= values.Length || values[index] == null)
            return null;

        var node = new TreeNode(values[index]!.Value);
        node.left = BuildTree(values, 2 * index + 1);
        node.right = BuildTree(values, 2 * index + 2);
        return node;
    }

    private static int?[] TreeToArray(TreeNode? root)
    {
        if (root == null)
            return new int?[0];

        var result = new List<int?>();
        var queue = new Queue<TreeNode?>();
        queue.Enqueue(root);

        while (queue.Count > 0)
        {
            var node = queue.Dequeue();
            if (node == null)
            {
                result.Add(null);
            }
            else
            {
                result.Add(node.val);
                queue.Enqueue(node.left);
                queue.Enqueue(node.right);
            }
        }

        // Remove trailing nulls
        while (result.Count > 0 && result[result.Count - 1] == null)
        {
            result.RemoveAt(result.Count - 1);
        }

        return result.ToArray();
    }

    private static int?[] JsonElementToIntArray(JsonElement element)
    {
        if (element.ValueKind == JsonValueKind.Null)
            return new int?[0];

        var result = new int?[element.GetArrayLength()];
        for (int i = 0; i < element.GetArrayLength(); i++)
        {
            var item = element[i];
            result[i] = item.ValueKind == JsonValueKind.Null ? null : item.GetInt32();
        }
        return result;
    }

    private static bool ArraysEqual(int?[] arr1, int?[] arr2)
    {
        if (arr1.Length != arr2.Length)
            return false;

        for (int i = 0; i < arr1.Length; i++)
        {
            if (arr1[i] != arr2[i])
                return false;
        }

        return true;
    }
}
