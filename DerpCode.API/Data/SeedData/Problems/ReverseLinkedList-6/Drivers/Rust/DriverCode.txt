use std::cell::RefCell;
use std::rc::Rc;
use serde_json::Value;

mod base_driver;
use base_driver::{BaseDriver, ProblemDriver, TestCase};

mod solution;
use solution::{ListNode, Solution};

struct ReverseLinkedListDriver;

impl ProblemDriver for ReverseLinkedListDriver {
    fn parse_test_cases(&self, input: &Value, expected_output: &Value) -> Vec<TestCase> {
        let inputs = input.as_array().expect("Input should be an array");
        let expected_outputs = expected_output.as_array().expect("Expected output should be an array");
        
        inputs
            .iter()
            .zip(expected_outputs.iter())
            .map(|(input, expected)| TestCase {
                input: input.clone(),
                expected_output: expected.clone(),
            })
            .collect()
    }
    
    fn execute_test_case(&self, test_case: &TestCase, _index: usize) -> Result<Value, Box<dyn std::error::Error>> {
        let input_array = test_case.input.as_array().ok_or("Input is not an array")?;
        
        // Convert JSON array to linked list
        let head = json_array_to_linked_list(input_array)?;
        
        // Run the solution
        let reversed_head = Solution::reverse_list(head);
        
        // Convert result back to JSON array
        let result_array = linked_list_to_json_array(reversed_head);
        
        Ok(Value::Array(result_array))
    }
    
    fn compare_results(&self, actual: &Value, expected: &Value) -> bool {
        actual == expected
    }
}

fn main() {
    let driver = ReverseLinkedListDriver;
    let base_driver = BaseDriver::new(driver);
    base_driver.run();
}

fn json_array_to_linked_list(arr: &[Value]) -> Result<Option<Rc<RefCell<ListNode>>>, Box<dyn std::error::Error>> {
    if arr.is_empty() {
        return Ok(None);
    }
    
    let head = Rc::new(RefCell::new(ListNode::new(
        arr[0].as_i64().ok_or("Invalid integer in array")? as i32
    )));
    let mut current = head.clone();
    
    for val in &arr[1..] {
        let new_node = Rc::new(RefCell::new(ListNode::new(
            val.as_i64().ok_or("Invalid integer in array")? as i32
        )));
        current.borrow_mut().next = Some(new_node.clone());
        current = new_node;
    }
    
    Ok(Some(head))
}

fn linked_list_to_json_array(head: Option<Rc<RefCell<ListNode>>>) -> Vec<Value> {
    let mut result = Vec::new();
    let mut current = head;
    
    while let Some(node) = current {
        result.push(Value::Number(serde_json::Number::from(node.borrow().val)));
        current = node.borrow().next.clone();
    }
    
    result
}
