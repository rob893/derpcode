import { BaseDriver, ProblemDriverBase } from './base-driver';
import { inorderTraversal, TreeNode } from './solution';

interface TestCase {
    input: { treeArray: (number | null)[] };
    expectedOutput: number[];
}

/**
 * Problem-specific driver for Binary Tree Inorder Traversal problem.
 */
class InOrderTraversalDriver extends ProblemDriverBase {
    /**
     * Parse input as tree structures and expected output as arrays of integers.
     */
    parseTestCases(input: any[], expectedOutput: number[][]): TestCase[] {
        const testCases: TestCase[] = [];
        
        for (let i = 0; i < input.length; i++) {
            const treeArray = input[i].tree;
            const expected = expectedOutput[i];
            
            testCases.push({
                input: { treeArray: treeArray },
                expectedOutput: expected
            });
        }
        
        return testCases;
    }

    /**
     * Execute the inorderTraversal function with the test case inputs.
     */
    executeTestCase(testCase: TestCase, index: number): number[] {
        const { treeArray } = testCase.input;
        const root = this.buildTreeFromArray(treeArray);
        return inorderTraversal(root);
    }

    /**
     * Compare results using array equality.
     */
    compareResults(actual: number[], expected: number[]): boolean {
        if (actual === null && expected === null) return true;
        if (actual === null || expected === null) return false;
        if (actual.length !== expected.length) return false;
        
        for (let i = 0; i < actual.length; i++) {
            if (actual[i] !== expected[i]) return false;
        }
        
        return true;
    }

    /**
     * Format error message for failed tests.
     */
    formatErrorMessage(actual: number[], expected: number[]): string {
        const actualStr = actual === null ? 'null' : `[${actual.join(', ')}]`;
        const expectedStr = expected === null ? 'null' : `[${expected.join(', ')}]`;
        return `Expected ${expectedStr} but got ${actualStr}`;
    }

    /**
     * Build a binary tree from array representation.
     */
    private buildTreeFromArray(treeArray: (number | null)[]): TreeNode | null {
        if (!treeArray || treeArray.length === 0) return null;
        
        const root = new TreeNode(treeArray[0] as number);
        const queue: TreeNode[] = [root];
        
        let i = 1;
        while (queue.length > 0 && i < treeArray.length) {
            const current = queue.shift()!;
            
            // Left child
            if (i < treeArray.length && treeArray[i] !== null) {
                current.left = new TreeNode(treeArray[i] as number);
                queue.push(current.left);
            }
            i++;
            
            // Right child
            if (i < treeArray.length && treeArray[i] !== null) {
                current.right = new TreeNode(treeArray[i] as number);
                queue.push(current.right);
            }
            i++;
        }
        
        return root;
    }
}

// Create and run the driver
const driver = new BaseDriver(new InOrderTraversalDriver());
driver.run();
