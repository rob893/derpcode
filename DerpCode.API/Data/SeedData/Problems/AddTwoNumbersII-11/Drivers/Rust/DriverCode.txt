use serde_json::Value;
use std::fs;

mod base_driver;
use base_driver::{BaseDriver, ProblemDriver, TestCase};

mod solution;
use solution::Solution;

/// Problem-specific driver for AddTwoNumbersII problem.
pub struct AddTwoNumbersIIDriver;

impl ProblemDriver for AddTwoNumbersIIDriver {
    /// Parse input as array of pairs and expected output as array of integers.
    fn parse_test_cases(&self, input: &Value, expected_output: &Value) -> Vec<TestCase> {
        let input_array = input.as_array().expect("Input should be an array");
        let expected_array = expected_output.as_array().expect("Expected output should be an array");
        
        let mut test_cases = Vec::new();
        
        for i in 0..input_array.len() {
            let pair = input_array[i].as_array().expect("Input item should be a pair");
            let a = pair[0].as_i64().expect("Input should be integer") as i32;
            let b = pair[1].as_i64().expect("Input should be integer") as i32;
            let expected = expected_array[i].clone();
            
            test_cases.push(TestCase {
                input: serde_json::json!({ "a": a, "b": b }),
                expected_output: expected,
            });
        }
        
        test_cases
    }

    /// Execute the add function with the test case inputs, but first validate no + operator is used.
    fn execute_test_case(&self, test_case: &TestCase, _index: usize) -> Result<Value, Box<dyn std::error::Error>> {
        // First, validate that the solution doesn't use prohibited operators
        self.validate_source_code()?;
        
        let a = test_case.input["a"].as_i64().ok_or("Missing 'a' input")? as i32;
        let b = test_case.input["b"].as_i64().ok_or("Missing 'b' input")? as i32;
        
        let result = Solution::add(a, b);
        Ok(serde_json::json!(result))
    }

    /// Compare results using simple equality.
    fn compare_results(&self, actual: &Value, expected: &Value) -> bool {
        actual == expected
    }
}

impl AddTwoNumbersIIDriver {
    /// Validate that the source code doesn't contain prohibited operators.
    fn validate_source_code(&self) -> Result<(), Box<dyn std::error::Error>> {
        match fs::read_to_string("solution.rs") {
            Ok(solution_code) => {
                // Remove comments to avoid false positives
                let mut clean_code = solution_code.clone();
                
                // Remove single-line comments
                let lines: Vec<&str> = clean_code.lines().collect();
                let mut clean_lines = Vec::new();
                
                for line in lines {
                    if let Some(comment_pos) = line.find("//") {
                        clean_lines.push(&line[..comment_pos]);
                    } else {
                        clean_lines.push(line);
                    }
                }
                
                clean_code = clean_lines.join("\n");
                
                // Remove multi-line comments
                while let Some(start) = clean_code.find("/*") {
                    if let Some(end) = clean_code[start..].find("*/") {
                        clean_code.replace_range(start..start + end + 2, "");
                    } else {
                        break;
                    }
                }
                
                // Remove string literals
                while let Some(start) = clean_code.find('"') {
                    if let Some(end) = clean_code[start + 1..].find('"') {
                        clean_code.replace_range(start..start + end + 2, "\"\"");
                    } else {
                        break;
                    }
                }
                
                while let Some(start) = clean_code.find('\'') {
                    if let Some(end) = clean_code[start + 1..].find('\'') {
                        clean_code.replace_range(start..start + end + 2, "''");
                    } else {
                        break;
                    }
                }
                
                // Check for prohibited operators using regex-like pattern matching
                let chars: Vec<char> = clean_code.chars().collect();
                let len = chars.len();
                
                for i in 0..len {
                    match chars[i] {
                        '+' => {
                            // Check various + operator patterns
                            if i > 0 && i < len - 1 {
                                let prev_char = chars[i - 1];
                                let next_char = chars[i + 1];
                                
                                // + surrounded by spaces, digits, parentheses
                                if prev_char == ' ' && next_char == ' ' ||  // " + "
                                   prev_char.is_ascii_digit() ||            // "5+"
                                   next_char.is_ascii_digit() ||            // "+5"
                                   prev_char == ')' ||                      // ")+"
                                   next_char == '(' ||                      // "+("
                                   next_char == '=' {                       // "+="
                                    return Err("Prohibited operator detected in solution.".into());
                                }
                            }
                            
                            // Check for ++ operator
                            if i < len - 1 && chars[i + 1] == '+' {
                                return Err("Prohibited operator detected in solution.".into());
                            }
                        }
                        '-' => {
                            // Check various - operator patterns (but not negative numbers)
                            if i > 0 && i < len - 1 {
                                let prev_char = chars[i - 1];
                                let next_char = chars[i + 1];
                                
                                // Only flag as subtraction if preceded by identifier, digit, or )
                                if (prev_char.is_ascii_alphanumeric() || prev_char == ')') &&
                                   (next_char == ' ' || next_char.is_ascii_digit() || next_char == '(') {
                                    return Err("Prohibited operator detected in solution.".into());
                                }
                                
                                if next_char == '=' {  // "-="
                                    return Err("Prohibited operator detected in solution.".into());
                                }
                            }
                            
                            // Check for -- operator
                            if i < len - 1 && chars[i + 1] == '-' {
                                return Err("Prohibited operator detected in solution.".into());
                            }
                        }
                        _ => {}
                    }
                }
                
                Ok(())
            }
            Err(_) => {
                // If solution file doesn't exist, skip validation
                Ok(())
            }
        }
    }
}

fn main() {
    // Create and run the driver
    let driver = BaseDriver::new(AddTwoNumbersIIDriver);
    driver.run();
}
